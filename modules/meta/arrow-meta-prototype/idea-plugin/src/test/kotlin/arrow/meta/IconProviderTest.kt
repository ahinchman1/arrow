package arrow.meta

import arrow.meta.dsl.platform.cli
import com.intellij.openapi.util.Iconable
import com.intellij.testFramework.fixtures.LightPlatformCodeInsightFixture4TestCase
import org.intellij.lang.annotations.Language
import org.jetbrains.kotlin.idea.KotlinFileType
import org.jetbrains.kotlin.nj2k.postProcessing.type
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.types.UnresolvedType
import org.junit.Assert
import org.junit.Test

class IconProviderTest : LightPlatformCodeInsightFixture4TestCase() {
  @Test
  fun testIconProvider() {
    cli {
      Assert.fail("cli must not be active in an IDE test")
    }

    // configureByText creates a Kotlin file on the fly
    // it's created for the current temp project
    val file = myFixture.configureByText("arrow.kt",
      """
      package test
      
      import arrow.higherKind
      
      @higherkind
      class Id<out A>(val value: A)
      
      val <caret>x: IdOf<Int> = Id(1)
      """.trimIndent())
    Assert.assertTrue(file.fileType is KotlinFileType)

    // the <caret> marker in the text above automatically sets the
    // initial caret position in the (headless) editor which is
    // available at myFixture.editor
    // myFixture.editor.document provides the document, which is being edited
    val psi = myFixture.elementAtCaret
    Assert.assertTrue(psi is KtProperty)

    // most implementations of PsiElement, including the default implementation,
    // retrieve the return value of getIcon() from the registered IconProviders.
    val icon = psi.getIcon(Iconable.ICON_FLAG_VISIBILITY)
    Assert.assertNotNull(icon)
    // fixme: test for a specific icon as soon as the compiler plugins
    //  provide custom icons for PSI elements.
    // this kind of icon is unrelated to gutter icons

    // fixme: this is not yet working, because
    //   - the kotlin class was created on the fly and the Kotlin compiler plugin has
    //   not yet been run on this source file
    //   Possible fixes:
    //   - integrate the Kotlin compiler and the Arrow compiler plugin somehow at runtime
    //   - don't create a file on-the-fly, but store it on disk. Generate the arrow bytecode and add
    //     the generated bytecode data to the vcs.
    //     Then make use of it in the tests, i.e. load the source from disk
    val psiType = (psi as KtProperty).type()
    Assert.assertTrue("psi element must resolve to a valid type", psiType !is UnresolvedType)
  }
}
